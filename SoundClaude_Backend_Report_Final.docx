# TITLE OF PROJECT
# SoundClaude - AI-Powered Music Analysis and Discovery Platform

A Project Report for "Web Programming Course"

Submitted by

NAME OF THE CANDIDATE
NAME OF THE CANDIDATE
NAME OF THE CANDIDATE

Under the Guidance of

Prof. Vijayetha Thoday/Prof. Rojal Tuscano

for the course "Web Programming"

in partial fulfillment for the award of the degree of

BTECH /MBATECH

At

Department of Computer Engineering,
MPSTME, NMIMS.

APRIL, 2025

---

## DECLARATION

We, ________________, Roll No. __________ BTECH/MBATECH, IV semester understand that plagiarism is defined as anyone or combination of the following:

1. Un-credited verbatim copying of individual sentences, paragraphs or illustration (such as graphs, diagrams, etc.) from any source, published or unpublished, including the internet.

2. Un-credited improper paraphrasing of pages paragraphs (changing a few words phrases, or rearranging the original sentence order)

3. Credited verbatim copying of a major portion of a paper (or thesis chapter) without clear delineation of who did wrote what. (Source: IEEE, The institute, Dec. 2004)

4. We have made sure that all the ideas, expressions, graphs, diagrams, etc., that are not a result of my work, are properly credited. Long phrases or sentences that had to be used verbatim from published literature have been clearly identified using quotation marks.

5. We affirm that no portion of my work can be considered as plagiarism and I take full responsibility if such a complaint occurs. I understand fully well that the guide of the seminar/ project report may not be in a position to check for the possibility of such incidences of plagiarism in this body of work.

Names: __________, _____________, ____________, ______________

Roll Nos. : __________, _____________, ____________, ______________

Place: Mumbai

Date:

---

## CERTIFICATE

This is to certify that the project entitled "SoundClaude - AI-Powered Music Analysis and Discovery Platform" is the bonafide work carried out by ________________ of BTECH/MBATECH, MPSTME (NMIMS), Mumbai, during the VI semester of the academic year__________, in partial fulfillment of the requirements for the Course Web Programming

___________________
Prof. Vijayetha Thoday/Prof. Rojal Tuscano                                                                                                                                 
Internal Mentor                                                                                                                                            

_______________________                                       ________________________
Examiner 1                                                   Examiner 2

---

## Table of contents

| CHAPTER NO. | TITLE | PAGE NO. |
|-------------|-------|----------|
| 1. | INTRODUCTION<br>SCOPE<br>PURPOSE | |
| 2. | DESCRIPTION OF MODULES | |
| 3. | SOFTWARES/API's/ DATABASE USED WITH DESCRIPTION | |
| 4. | METHODS IMPLEMENTED | |
| 5. | CODE SNIPPETS | |
| 6. | GUI/DATABASE SCREENSHOTS | |
| 7. | CONCLUSION & FUTURE SCOPE | |
| 8. | APPLICATIONS IF ANY | |

---

## CHAPTER 1: INTRODUCTION

### 1.1 Introduction

SoundClaude is an innovative Node.js + Express application designed for music analysis and discovery, using MongoDB for data storage. This application allows users to upload audio files, analyze them with AI (SONOTELLER.AI API), and search for songs based on mood and themes.

The backend of SoundClaude serves as the foundation of the entire application, handling file uploads, AI processing, database management, and API endpoints that power the user-facing features. It employs modern web technologies and cloud services to deliver a scalable and efficient solution for music file processing and retrieval.

It uses Node.js for server-side logic, Express for handling HTTP requests, and MongoDB for storing data including large audio files via GridFS. The application uses ES6 modules (import instead of require) for modern JavaScript compatibility, offering better tree-shaking and module management compared to CommonJS.

### 1.2 Scope

The scope of the SoundClaude backend encompasses:

1. **Audio File Management**: Secure upload, storage, and retrieval of audio files with appropriate metadata.
2. **AI-Powered Analysis**: Integration with advanced AI services to analyze music files, extract lyrics, identify moods, themes, and create meaningful summaries.
3. **Vector-Based Search**: Implementation of semantic search functionality using AI-generated embeddings to find music based on contextual similarity rather than just keywords.
4. **External Service Integration**: Seamless integration with third-party services for file hosting and AI analysis.
5. **Scalable Infrastructure**: Leveraging cloud database solutions for efficient data management and retrieval.
6. **RESTful API Development**: Creation of well-designed API endpoints for frontend communication.

### 1.3 Purpose

The primary purpose of the SoundClaude backend is to:

1. **Enable Content Discovery**: Help users discover music based on semantic similarity and AI-generated metadata.
2. **Streamline Music Analysis**: Automate the extraction of meaningful information from audio files.
3. **Provide Efficient Storage Solutions**: Implement appropriate storage mechanisms for both audio files and their associated metadata.
4. **Support Scale**: Build a foundation that can handle growing user bases and content libraries.
5. **Ensure Security**: Protect user data and content through proper authentication and authorization mechanisms.
6. **Deliver Performance**: Optimize API endpoints and database operations for responsive user experiences.

---

## CHAPTER 2: DESCRIPTION OF MODULES

The SoundClaude backend is organized into several key modules, each responsible for specific aspects of the application's functionality:

### 2.1 Database Connection Module (db.js)

This module manages the connection to MongoDB, ensuring secure and efficient database access:

- **Environment Variable Management**: Uses dotenv to load environment variables from a .env file, allowing secure management of sensitive data like database credentials.
- **Connection Establishment**: Creates and maintains a connection to MongoDB using the MongoClient.
- **Singleton Pattern**: Implements a singleton pattern for database connection to avoid multiple connections, improving performance.
- **Error Handling**: Robust error handling for database connection issues.
- **Database Selection**: Sets up and returns the "soundclaude_db" database for use throughout the application.

### 2.2 File Upload and Storage Module

This module handles the secure uploading and storage of audio files. It implements:

- **Local Temporary Storage**: Uses Multer middleware to handle multipart/form-data uploads and temporarily store files on the server.
- **File Validation**: Ensures uploaded files are valid audio formats and within size limits.
- **External Hosting**: Uploads files to Catbox.moe for accessible hosting.
- **MongoDB GridFS Storage**: Stores audio files in MongoDB using GridFS for efficient binary data management.
- **Cleanup Processes**: Removes temporary files after processing is complete.

### 2.3 AI Analysis Module

This module leverages external AI services to analyze audio content:

- **Sonoteller Integration**: Connects with the Sonoteller AI API to analyze audio files and extract key information.
- **Metadata Extraction**: Processes results to extract language, mood, themes, keywords, and other metadata.
- **Vector Embedding Generation**: Uses Google's Generative AI to create vector embeddings for semantic search.
- **Data Transformation**: Formats AI-generated data for efficient storage and retrieval.

### 2.4 Search and Retrieval Module

This module enables advanced search and content retrieval:

- **Vector Similarity Search**: Implements cosine similarity calculations for semantic searching.
- **Audio Streaming**: Provides endpoints for streaming audio files directly from GridFS.
- **Result Formatting**: Prepares search results with relevant metadata for frontend consumption.

### 2.5 API Endpoints Module (index.js)

This module sets up the server, handles file uploads, processes audio with external APIs, and provides search functionality through well-defined REST endpoints:

- **/upload**: Handles file uploads and processing.
- **/search**: Provides semantic search functionality.
- **/audio/:id**: Streams audio files from the database.

---

## CHAPTER 3: SOFTWARES/API's/DATABASE USED WITH DESCRIPTION

### 3.1 Development Environment

- **Node.js**: JavaScript runtime environment that allows JavaScript to run on the server side, enabling asynchronous, event-driven programming.
- **Express.js**: Web framework built on Node.js, simplifying the creation of web servers and handling HTTP requests.
- **ES Modules**: Modern JavaScript module system for better code organization, offering better tree-shaking and module management compared to CommonJS.

### 3.2 External APIs

- **Sonoteller AI (RapidAPI)**: Service that analyzes music files to extract lyrics, moods, themes, and other metadata.
- **Google Generative AI API**: Used for generating vector embeddings of text data for semantic search.
- **Catbox.moe API**: External file hosting service for storing and serving audio files.

### 3.3 Database Technologies

- **MongoDB Atlas**: Cloud-hosted MongoDB service for storing application data. MongoDB is a NoSQL database that stores data in a flexible, JSON-like format, ideal for handling unstructured data like audio metadata. It was chosen specifically as an ideal cloud-based solution for storing data and facilitating team collaboration.
- **MongoDB GridFS**: System for storing and retrieving large files within MongoDB.
- **MongoDB Node.js Driver**: Official MongoDB driver for Node.js applications, including MongoClient for connecting to the MongoDB server and ServerApiVersion for specifying the API version for compatibility.

### 3.4 File Handling Libraries

- **Multer**: Middleware for handling multipart/form-data, primarily used for file uploads.
- **Form-Data**: Library for creating form data objects for API requests.
- **fs**: Node.js built-in module for file system operations like creating directories and reading files.
- **path**: Node.js module for file path operations, like joining directories.

### 3.5 Network and Request Handling

- **Axios**: Promise-based HTTP client for making API requests, used for uploading to Catbox.moe.
- **node-fetch**: Modern HTTP client for requests, used for the Sonoteller API.
- **CORS**: Cross-Origin Resource Sharing middleware to enable secure cross-origin requests, allowing requests from different domains, crucial for web applications.

### 3.6 Environment and Configuration

- **dotenv**: Module for loading environment variables from .env files, allowing secure management of sensitive data like database credentials.
- **fileURLToPath**: Converts file URLs to paths, necessary for ES6 modules.

---

## CHAPTER 4: METHODS IMPLEMENTED

### 4.1 Database Connection Management

#### 4.1.1 Singleton Pattern for Database Connection
The application implements a singleton pattern for database connection to optimize performance:

```javascript
let db;

async function connectToDatabase() {
  if (db) return db;
  try {
    await client.connect();
    await client.db("admin").command({ ping: 1 });
    console.log("Successfully connected to MongoDB!");
    db = client.db("soundclaude_db");
    return db;
  } catch (error) {
    console.error("Error connecting to database:", error);
    throw error;
  }
}
```

This approach:
- Checks if a connection already exists before creating a new one
- Uses a try/catch block to handle connection errors
- Pings the admin database to verify connection success
- Sets and returns the application database

### 4.2 File Upload and Processing

#### 4.2.1 Multi-Stage Upload Process
The system implements a sophisticated multi-stage upload process that involves:
1. Initial validation and temporary storage
2. External hosting on Catbox.moe
3. AI analysis via Sonoteller
4. Permanent storage in MongoDB GridFS
5. Metadata indexing with vector embeddings

#### 4.2.2 File Validation and Storage Configuration
The application configures Multer middleware to handle file uploads with specific restrictions:

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${path.basename(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 15 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('audio/')) {
      cb(null, true);
    } else {
      cb(new Error('Only audio files are allowed'));
    }
  }
});
```

This setup:
- Creates unique filenames based on timestamp and original name
- Limits file size to 15MB
- Restricts uploads to audio file types only

### 4.3 Vector Embedding for Semantic Search

#### 4.3.1 Text Aggregation for Embedding
The system combines various text elements from the AI analysis to create a comprehensive representation:
- Summary text
- Keywords
- Mood descriptors
- Theme descriptors

#### 4.3.2 Vector Generation and Similarity Calculation
Google's Generative AI API is used to create high-dimensional vector embeddings which are then compared using cosine similarity:

```javascript
// Cosine similarity function
function cosineSimilarity(vecA, vecB) {
  const dot = vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);
  const magA = Math.sqrt(vecA.reduce((sum, val) => sum + val * val, 0));
  const magB = Math.sqrt(vecB.reduce((sum, val) => sum + val * val, 0));
  return dot / (magA * magB);
}
```

### 4.4 External Service Integration

#### 4.4.1 Catbox.moe Integration
Implementation of form-based file uploads to external hosting:

```javascript
async function uploadToCatbox(filePath, filename) {
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', fs.createReadStream(filePath), filename);

  const response = await axios.post('https://catbox.moe/user/api.php', form, {
    headers: form.getHeaders(),
    maxContentLength: Infinity,
    maxBodyLength: Infinity
  });
  return response.data;
}
```

#### 4.4.2 Sonoteller AI Integration
Implementation of API calls to the Sonoteller service for audio analysis:

```javascript
async function processWithSonoteller(songUrl) {
  const encodedParams = new URLSearchParams();
  encodedParams.set('file', songUrl);

  const apiUrl = 'https://sonoteller-ai1.p.rapidapi.com/lyrics_ddex';
  const apiOptions = {
    method: 'POST',
    headers: {
      'x-rapidapi-key': process.env.RAPID_API_KEY,
      'x-rapidapi-host': 'sonoteller-ai1.p.rapidapi.com',
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: encodedParams
  };

  const response = await fetch(apiUrl, apiOptions);
  const responseText = await response.text();

  return JSON.parse(responseText);
}
```

### 4.5 GridFS Integration for Audio Storage and Streaming

#### 4.5.1 Audio File Storage with Metadata
Implementation of GridFS for storing audio files with associated metadata:

```javascript
async function uploadToGridFS(filePath, filename, mimeType) {
  const db = await connectToDatabase();
  const bucket = new GridFSBucket(db, { bucketName: 'songs_audio' });

  return new Promise((resolve, reject) => {
    const uploadStream = bucket.openUploadStream(filename, {
      contentType: mimeType
    });
    const readStream = fs.createReadStream(filePath);

    readStream.pipe(uploadStream)
      .on('error', reject)
      .on('finish', () => resolve(uploadStream.id));
  });
}
```

#### 4.5.2 Audio Streaming Endpoint
Implementation of streaming audio files directly from GridFS:

```javascript
app.get('/audio/:id', async (req, res) => {
  try {
    const db = await connectToDatabase();
    const bucket = new GridFSBucket(db, { bucketName: 'songs_audio' });

    const fileId = new ObjectId(req.params.id);
    const downloadStream = bucket.openDownloadStream(fileId);

    if (req.query.download === 'true') {
      const file = await bucket.find({ _id: fileId }).toArray();
      const filename = file[0]?.filename || 'audio.mp3';
      res.set('Content-Disposition', `attachment; filename="${filename}"`);
    }

    downloadStream.pipe(res);
  } catch (error) {
    console.error('Error streaming audio:', error);
    if (error.message.includes('FileNotFound')) {
      res.status(404).json({ error: 'Audio file not found' });
    } else {
      res.status(500).json({ error: 'Failed to stream audio' });
    }
  }
});
```

---

## CHAPTER 5: CODE SNIPPETS

### 5.1 Database Connection (db.js)

```javascript
import dotenv from 'dotenv';
import { MongoClient, ServerApiVersion } from 'mongodb';

dotenv.config();

const uri = `mongodb+srv://SoundClaude_Admin:${process.env.MONGO_PASSWORD}@soundclaude.lffsfo8.mongodb.net/?retryWrites=true&w=majority&appName=SoundClaude`;

const client = new MongoClient(uri, {
  serverApi: {
    version: ServerApiVersion.v1,
    strict: true,
    deprecationErrors: true,
  }
});

let db;

async function connectToDatabase() {
  if (db) return db;
  try {
    await client.connect();
    await client.db("admin").command({ ping: 1 });
    console.log("Successfully connected to MongoDB!");
    db = client.db("soundclaude_db");
    return db;
  } catch (error) {
    console.error("Error connecting to database:", error);
    throw error;
  }
}

export { connectToDatabase };
```

### 5.2 File Upload Endpoint

```javascript
app.post('/upload', upload.single('songFile'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    console.log(`File uploaded locally: ${req.file.originalname}`);

    const songUrl = await uploadToCatbox(req.file.path, req.file.originalname);
    const sonotellerResult = await processWithSonoteller(songUrl);
    const gridFsId = await uploadToGridFS(req.file.path, req.file.filename, req.file.mimetype);
    const songId = await storeSongData(sonotellerResult, gridFsId, req.file.filename, songUrl);

    // Clean up local file
    fs.unlinkSync(req.file.path);

    return res.status(200).json({
      success: true,
      message: 'Song processed and stored successfully',
      songId: songId.toString(),
      details: sonotellerResult
    });
  } catch (error) {
    console.error('Upload error:', error);
    return res.status(500).json({ error: 'File upload failed', details: error.message });
  }
});
```

### 5.3 Vector Embedding and Song Data Storage

```javascript
async function storeSongData(songData, fileId, filename, songUrl) {
  const db = await connectToDatabase();
  const combinedText = [
    songData.summary || '',
    ...Object.values(songData.keywords || {}),
    ...Object.values(songData['ddex moods'] || {}),
    ...Object.values(songData['ddex themes'] || {})
  ].join(' ');

  const embeddingResponse = await embedModel.embedContent(combinedText);
  const embedding = embeddingResponse.embedding.values;

  const song = {
    songUrl,
    audioFileId: fileId,
    filename,
    language: songData.language || 'unknown',
    language_iso: songData["language-iso"] || 'unknown',
    summary: songData.summary || '',
    explicit: songData.explicit || false,
    keywords: Object.values(songData.keywords || {}),
    ddex_moods: Object.values(songData["ddex moods"] || {}),
    ddex_themes: Object.values(songData["ddex themes"] || {}),
    flags: songData.flags || {},
    embedding,
    created_at: new Date(),
  };

  const collection = db.collection('songs');
  const result = await collection.insertOne(song);
  return result.insertedId;
}
```

### 5.4 Semantic Search Implementation

```javascript
app.get('/search', async (req, res) => {
  try {
    const searchQuery = req.query.q;
    if (!searchQuery) {
      return res.status(400).json({ error: 'Search query is required' });
    }

    const embeddingResponse = await embedModel.embedContent(searchQuery);
    const queryEmbedding = embeddingResponse.embedding.values;

    const db = await connectToDatabase();
    const collection = db.collection('songs');
    const songs = await collection.find({}).toArray();

    const similarities = songs.map(song => {
      const similarity = cosineSimilarity(queryEmbedding, song.embedding);
      return {
        songId: song._id,
        similarity,
        songData: {
          filename: song.filename,
          summary: song.summary,
          keywords: song.keywords,
          ddex_moods: song.ddex_moods,
          ddex_themes: song.ddex_themes,
          audioFileId: song.audioFileId.toString()
        }
      };
    });

    similarities.sort((a, b) => b.similarity - a.similarity);
    const topSongs = similarities.slice(0, 5);

    return res.status(200).json({
      success: true,
      results: topSongs
    });
  } catch (error) {
    console.error('Search error:', error);
    return res.status(500).json({ error: 'Search failed', details: error.message });
  }
});
```

### 5.5 Server Initialization

```javascript
// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Upload files at: http://localhost:${PORT}/upload`);
});
```

---

## CHAPTER 6: GUI/DATABASE SCREENSHOTS

*Note: In an actual report, this section would include screenshots of the database structure, MongoDB collections, API responses, and any GUI elements of the backend management tools.*

**Example MongoDB Document Structure:**

```json
{
  "_id": "ObjectId(6452ab3d8f95e1c3b2a5d7e9)",
  "songUrl": "https://catbox.moe/c/1a2b3c",
  "audioFileId": "ObjectId(6452ab3d8f95e1c3b2a5d7e8)",
  "filename": "1650123456-mysong.mp3",
  "language": "English",
  "language_iso": "en",
  "summary": "An upbeat pop song about overcoming challenges",
  "explicit": false,
  "keywords": ["upbeat", "motivational", "pop", "overcoming"],
  "ddex_moods": ["happy", "energetic", "positive"],
  "ddex_themes": ["success", "challenge", "journey"],
  "flags": {
    "is_instrumental": false
  },
  "embedding": [0.1, 0.2, 0.3, ...], // Truncated for brevity
  "created_at": "2024-04-14T15:30:21.123Z"
}
```

**Example API Endpoint Response for Search:**

```json
{
  "success": true,
  "results": [
    {
      "songId": "6452ab3d8f95e1c3b2a5d7e9",
      "similarity": 0.92,
      "songData": {
        "filename": "1650123456-mysong.mp3",
        "summary": "An upbeat pop song about overcoming challenges",
        "keywords": ["upbeat", "motivational", "pop", "overcoming"],
        "ddex_moods": ["happy", "energetic", "positive"],
        "ddex_themes": ["success", "challenge", "journey"],
        "audioFileId": "6452ab3d8f95e1c3b2a5d7e8"
      }
    },
    // More results...
  ]
}
```

---

## CHAPTER 7: CONCLUSION & FUTURE SCOPE

### 7.1 Conclusion

The SoundClaude backend successfully implements a modern, scalable system for audio file processing, analysis, and retrieval. By leveraging cutting-edge technologies like Node.js, Express, MongoDB GridFS for file storage, AI-powered analysis through Sonoteller, and vector embeddings for semantic search, the system provides a robust foundation for a music discovery and sharing platform.

Key achievements of the project include:

1. **Modern JavaScript Implementation**: Using ES6 modules for better code organization and maintainability.

2. **Seamless Integration of Multiple Services**: The backend successfully orchestrates several third-party services and APIs to deliver a cohesive experience.

3. **Efficient Data Storage and Retrieval**: The use of MongoDB with GridFS provides an efficient solution for storing both audio files and their associated metadata.

4. **Advanced Search Capabilities**: The implementation of vector embeddings and cosine similarity enables users to find relevant content beyond simple keyword matching.

5. **Scalable Architecture**: The modular design and cloud-based components ensure the system can scale to accommodate growing user bases and content libraries.

6. **Comprehensive Error Handling**: Robust error management across all operations ensures system stability and user-friendly error messages.

### 7.2 Future Scope

While the current implementation provides a solid foundation, several enhancements could further improve the SoundClaude backend:

1. **User Authentication and Authorization**: Implementing a comprehensive user management system would enable personalized experiences and content ownership.

2. **Advanced Audio Processing**: Integrating additional audio analysis features like beat detection, tempo analysis, and genre classification could enhance the metadata richness.

3. **Recommendation Engine**: Building upon the vector embeddings to create a recommendation system that suggests similar songs based on user listening history.

4. **Caching Layer**: Implementing Redis or another caching solution to improve performance for frequently accessed content.

5. **WebSockets for Real-time Updates**: Adding WebSocket support for real-time notifications and updates to enhance the user experience.

6. **Content Moderation**: Implementing automated content moderation using AI to ensure uploaded content adheres to community guidelines.

7. **Analytics Integration**: Adding analytics capabilities to track usage patterns and system performance.

8. **Mobile API Optimization**: Optimizing the API responses and payloads specifically for mobile clients to reduce data usage and improve performance.

9. **Containerization**: Converting the application to use Docker for easier deployment and scaling across different environments.

10. **Microservices Architecture**: Potentially splitting the monolithic application into microservices for better scalability and maintenance.

---

## CHAPTER 8: APPLICATIONS

The SoundClaude backend can support various applications in the music and audio content space:

### 8.1 Music Discovery Platform

The primary application is a music discovery platform where users can:
- Upload and share their music
- Discover new content through semantic search
- Explore music based on moods, themes, and keywords

### 8.2 Audio Content Management System

The backend can serve as a foundation for a content management system for audio files:
- Organized storage with rich metadata
- Efficient retrieval and streaming
- Powerful search capabilities

### 8.3 Music Analysis Tool

The AI capabilities make it suitable for a music analysis tool:
- Automated extraction of lyrics, moods, and themes
- Language detection for international content
- Identification of explicit content

### 8.4 Educational Platform

The system could support music education applications:
- Categorization of music by style, mood, or theme
- Analysis of musical components for learning purposes
- Collaborative sharing of educational audio content

### 8.5 Podcast Management Platform

With minor modifications, the backend could support podcast management:
- Episode storage and streaming
- Content analysis for episode themes and topics
- Semantic search across podcast episodes

---

*Note: This report was created based on the analysis of the SoundClaude backend code and represents an academic exercise for the "Web Programming" course.*